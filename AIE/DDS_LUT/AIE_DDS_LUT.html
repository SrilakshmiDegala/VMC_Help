<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>DDS LUT</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="/proj/xhdhdstaff5/sdegala/Head1/HEAD/VMCHELP20242/xmc-matlab.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">DDS LUT</h1>
</header>
<section id="dds-lut" class="level1">
<h1>DDS LUT</h1>
<p><img src="./Images/block.png" /></p>
<section id="library" class="level2">
<h2>Library</h2>
<p>AI Engine/DSP/Buffer IO</p>
</section>
<section id="description" class="level2">
<h2>Description</h2>
<p>This block implements the Direct Digital Synthesizer (DDS) targeted for AI Engines and uses buffer interface.</p>
</section>
<section id="parameters" class="level2">
<h2>Parameters</h2>
<section id="main" class="level3">
<h3>Main</h3>
<section id="output-data-type" class="level4">
<h4>Output data type</h4>
<p>Sets the output data type.</p>
</section>
<section id="sfdr" class="level4">
<h4>SFDR</h4>
<p>Specifies the Spurious Free Dynamic Range (in dB) of the output signal. The maximum theoretical SFDR is 96 dB for <code>cint16</code>, 180 dB for <code>cint32</code>, and 138 dB for <code>cfloat</code>.</p>
</section>
<section id="samples-per-frame" class="level4">
<h4>Samples per frame</h4>
<p>Specifies the number of samples in the output frame. This must be a multiple of 'N' in each data loop. The value of 'N' varies based on the AIE architecture and data type are given in the below table:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>AIE</th>
<th>AIE-ML</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>cint16</code></td>
<td>64</td>
<td>64</td>
</tr>
<tr class="even">
<td><code>cint32</code></td>
<td>16</td>
<td>64</td>
</tr>
<tr class="odd">
<td><code>cfloat</code></td>
<td>4</td>
<td>N/A</td>
</tr>
</tbody>
</table>
</section>
<section id="reload-initial-phase-via-input-port" class="level4">
<h4>Reload initial phase via input port</h4>
<p>Allows the intial phase to be reloaded during simulation via an input port.</p>
</section>
<section id="phase-increment" class="level4">
<h4>Phase increment</h4>
<p>Specifies the phase increment between samples. The value must be in the range 0 to 2^31 and the default value is 0.</p>
<p>Phase increment is calculated using the formula <code>(Fo*(2^N))/Fs</code>.</p>
<p>Where:</p>
<ul>
<li>Fo = Output frequency</li>
<li>N = 32, which represents the accumulator width, and it is fixed</li>
<li>Fs = Sampling frequency</li>
</ul>
<p>For example, for a sampling frequency of 1 Gsps and output frequency of 100 MHz, the Phase Increment should be <code>2^32/10</code>.</p>
</section>
<section id="initial-phase-offset" class="level4">
<h4>Initial phase offset</h4>
<p>Specifies the initial value of the phase accumulator.</p>
</section>
<section id="rounding-mode" class="level4">
<h4>Rounding mode</h4>
<p>Describes the selection of rounding to be applied during the shift down stage of processing.</p>
<p>The following modes are available:</p>
<ul>
<li><strong>Floor:</strong> Truncate LSB, always round down (towards negative infinity).</li>
<li><strong>Ceiling:</strong> Always round up (towards positive infinity).</li>
<li><strong>Round to positive infinity:</strong> Round halfway towards positive infinity.</li>
<li><strong>Round to negative infinity:</strong> Round halfway towards negative infinity.</li>
<li><strong>Round symmetrical to infinity:</strong> Round halfway towards infinity (away from zero).</li>
<li><strong>Round symmetrical to zero:</strong> Round halfway towards zero (away from infinity).</li>
<li><strong>Round convergent to even:</strong> Round halfway towards nearest even number.</li>
<li><strong>Round convergent to odd:</strong> Round halfway towards nearest odd number.</li>
</ul>
<p>No rounding is performed on the <strong>Floor</strong> or <strong>Ceiling</strong> modes. Other modes round to the nearest integer. They differ only in how they round for values that are exactly between two integers.</p>
</section>
<section id="saturation-mode" class="level4">
<h4>Saturation mode</h4>
<p>Describes the selection of saturation to be applied during the shift down stage of processing.</p>
<p>The following modes are available:</p>
<ul>
<li><strong>None:</strong> No saturation is performed and the value is truncated on the MSB side.</li>
<li><strong>Asymmetric:</strong> Rounds an n-bit signed value in the range <code>-2^(n-1)</code> to <code>2^(n-1)-1</code>.</li>
<li><strong>Symmetric:</strong> Rounds an n-bit signed value in the range <code>-2^(n-1)-1</code> to <code>2^(n-1)-1</code>.</li>
</ul>
</section>
<section id="sample-time" class="level4">
<h4>Sample time</h4>
<p>Specifies the sample time for the output signal.</p>
<div class="noteBox">
The propagated block sample time in Simulink is equal to "Sample time" multipled by "Samples per frame".
</div>

</section>
</section>
</section>
<section id="examples" class="level2">
<h2>Examples</h2>
<p><em><strong>Click on the images below to open each model.</strong></em></p>
</section>
<section id="related-blocks" class="level2">
<h2>Related blocks</h2>
<p><a href="matlab:helpview(vmcHelp(&#39;name&#39;,&#39;DDS&#39;,&#39;category&#39;,&#39;AIE&#39;))">DDS</a></p>
</section>
<section id="references" class="level2">
<h2>References</h2>
<p>This block uses the Vitis DSP library implementation of DDS. For more details on this implementation please click <a href="https://docs.xilinx.com/r/en-US/Vitis_Libraries/dsp/user_guide/L2/func-dds.html">here</a>.</p>
<hr />
<p>Copyright (C) 2024 Advanced Micro Devices, Inc. All rights reserved.</p>
<p>SPDX-License-Identifier: MIT</p>
</section>
</section>
</body>
</html>
