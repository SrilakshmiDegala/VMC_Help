<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Mixer LUT</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="/proj/xhdhdstaff5/sdegala/Head1/HEAD/VMCHELP20242/xmc-matlab.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Mixer LUT</h1>
</header>
<section id="mixer-lut" class="level1">
<h1>Mixer LUT</h1>
<p><img src="./Images/block.png" /></p>
<section id="library" class="level2">
<h2>Library</h2>
<p>AI Engine/DSP/Buffer IO</p>
</section>
<section id="description" class="level2">
<h2>Description</h2>
<p>This block implements the Mixer targeted for AI Engines.</p>
</section>
<section id="parameters" class="level2">
<h2>Parameters</h2>
<section id="output-data-type" class="level4">
<h4>Output data type</h4>
<p>Describes the types of individual data samples input to and output from the Mixer function. The supported data types are cint16, cint32, and cfloat.</p>
</section>
<section id="mixer-mode" class="level4">
<h4>Mixer mode</h4>
<p>This specifies the mixer operation modes. Two modes are supported by the Mixer function:</p>
<ul>
<li><p><strong>Single Input Mode</strong>: This is a DDS plus Mixer for a single data input port. Each data input sample is complex multiplied with the corresponding DDS sample to create a modulated signal that is written to the output window. This is the default Mixer mode.</p></li>
<li><p><strong>Dual Input Mode</strong>: This is a special configuration for symmetrical carriers and two data input ports. Each data sample of the first input is complex multiplied with the corresponding DDS sample to create a modulated signal. Each data sample of the second data input is complex multiplied with the conjugate (which is equivalent to a signal rotating in the opposite direction) of the DDS sample to create a second modulated signal. These two modulated signals are added together and written to the output window.</p></li>
</ul>
</section>
<section id="sfdr" class="level4">
<h4>SFDR</h4>
<p>Specifies the Spurious Free Dynamic Range (in dB) of the output signal. The maximum theoretical SFDR is 96 dB for <code>cint16</code>, 180 dB for <code>cint32</code>, and 138 dB for <code>cfloat</code>.</p>
</section>
<section id="number-of-parallel-outputs-ssr" class="level4">
<h4>Number of Parallel Outputs (SSR)</h4>
<p>This parameter specifies the number of output ports. The number of AI Engine kernels used is equal to the value of SSR parameter.</p>
</section>
<section id="input-frame-size-number-of-samples" class="level4">
<h4>Input frame size (Number of samples)</h4>
<p>Specifies the number of samples in the output frame. This must be a multiple of the number of samples output in each data loop, which varies based on the AIE architecture and data type:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>AIE</th>
<th>AIE-ML</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>cint16</code></td>
<td>64</td>
<td>256</td>
</tr>
<tr class="even">
<td><code>cint32</code></td>
<td>16</td>
<td>64</td>
</tr>
<tr class="odd">
<td><code>cfloat</code></td>
<td>4</td>
<td>N/A</td>
</tr>
</tbody>
</table>
</section>
<section id="reload-initial-phase-via-input-port" class="level4">
<h4>Reload initial phase via input port</h4>
<p>Allows the intial phase to be reloaded during simulation via an input port.</p>
</section>
<section id="phase-increment" class="level4">
<h4>Phase increment</h4>
<p>This specifies the phase increment between the samples. The value should be in the range 0 to 2^31.</p>
<p>Phase increment is calculated using the formula <code>(Fo*(2^N))/Fs</code>.</p>
<p>Where:</p>
<ul>
<li>Fo = Output frequency</li>
<li>N = 32, which represents the accumulator width, and it is fixed</li>
<li>Fs = Sampling frequency</li>
</ul>
</section>
<section id="initial-phase-offset" class="level4">
<h4>Initial phase offset</h4>
<p>Specifies the initial value of the phase accumulator.</p>
</section>
<section id="rounding-mode" class="level4">
<h4>Rounding mode</h4>
<p>Describes the selection of rounding to be applied during the shift down stage of processing.</p>
<p>The following modes are available:</p>
<ul>
<li><strong>Floor:</strong> Truncate LSB, always round down (towards negative infinity).</li>
<li><strong>Ceiling:</strong> Always round up (towards positive infinity).</li>
<li><strong>Round to positive infinity:</strong> Round halfway towards positive infinity.</li>
<li><strong>Round to negative infinity:</strong> Round halfway towards negative infinity.</li>
<li><strong>Round symmetrical to infinity:</strong> Round halfway towards infinity (away from zero).</li>
<li><strong>Round symmetrical to zero:</strong> Round halfway towards zero (away from infinity).</li>
<li><strong>Round convergent to even:</strong> Round halfway towards nearest even number.</li>
<li><strong>Round convergent to odd:</strong> Round halfway towards nearest odd number.</li>
</ul>
<p>No rounding is performed on the <strong>Floor</strong> or <strong>Ceiling</strong> modes. Other modes round to the nearest integer. They differ only in how they round for values that are exactly between two integers.</p>
</section>
<section id="saturation-mode" class="level4">
<h4>Saturation mode</h4>
<p>Describes the selection of saturation to be applied during the shift down stage of processing.</p>
<p>The following modes are available:</p>
<ul>
<li><strong>None:</strong> No saturation is performed and the value is truncated on the MSB side.</li>
<li><strong>Asymmetric:</strong> Rounds an n-bit signed value in the range <code>-2^(n-1)</code> to <code>2^(n-1)-1</code>.</li>
<li><strong>Symmetric:</strong> Rounds an n-bit signed value in the range <code>-2^(n-1)-1</code> to <code>2^(n-1)-1</code>.</li>
</ul>
</section>
</section>
<section id="examples" class="level2">
<h2>Examples</h2>
<p><em><strong>Click on the images below to open each model.</strong></em></p>
<p><a href="https://github.com/Xilinx/Vitis_Model_Composer/tree/2024.2/Examples/Block_Help/AIE/Mixer_LUT_Ex1"><img src="./Images/Mixer_LUT_Ex1.png" /></a></p>
<p><a href="https://github.com/Xilinx/Vitis_Model_Composer/tree/2024.2/Examples/Block_Help/AIE/Mixer_LUT_Ex2"><img src="./Images/Mixer_LUT_Ex2.png" /></a></p>
<p><a href="https://github.com/Xilinx/Vitis_Model_Composer/tree/2024.2/Examples/Block_Help/AIE/Mixer_LUT_Ex3"><img src="./Images/Mixer_LUT_Ex3.png" /></a></p>
</section>
<section id="related-blocks" class="level2">
<h2>Related blocks</h2>
<p><a href="matlab:helpview(vmcHelp(&#39;name&#39;,&#39;Mixer&#39;,&#39;category&#39;,&#39;AIE&#39;))">Mixer</a></p>
</section>
<section id="references" class="level2">
<h2>References</h2>
<p>This block uses the Vitis DSP library implementation of Mixer. For more details on this implementation please click <a href="https://docs.xilinx.com/r/en-US/Vitis_Libraries/dsp/user_guide/L2/func-dds.html">here</a>.</p>
<hr />
<p>Copyright (C) 2024 Advanced Micro Devices, Inc. All rights reserved.</p>
<p>SPDX-License-Identifier: MIT</p>
</section>
</section>
</body>
</html>
