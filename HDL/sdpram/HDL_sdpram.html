<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Simple Dual Port RAM</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="/proj/xhdhdstaff5/sdegala/Head1/HEAD/VMCHELP20242/xmc-matlab.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Simple Dual Port RAM</h1>
</header>
<section id="simple-dual-port-ram" class="level1">
<h1>Simple Dual Port RAM</h1>
<p><img src="./Images/block.png" /></p>
<section id="description" class="level2">
<h2>Description</h2>
<p>The Simple Dual Port RAM block implements a random access memory (RAM), one port has read/write capability while the other port can only read. Thus, data can be read simultaneously from both ports, writing can only occur at one port at a time. This is also known as a 1.5 port RAM.</p>
<p>It is similar to the Dual Port RAM, but the Dual Port RAM has both write data output port and a read data output port.</p>
<section id="block-interface" class="level3">
<h3>Block Interface</h3>
<p>This block has one output port and four input ports for address (addra and addrb), input data, and write enable (WE) Optionally, you can also add a port enable for port A and Port B and synchronous reset signal to port B.</p>
<p>A simple dual-port RAM can be implemented using either distributed memory, block RAM, or UltraRAM resources in the FPGA.</p>
<section id="write-mode" class="level4">
<h4>Write Mode</h4>
<p>When the Simple Dual Port RAM block is implemented in block RAM, you can set the write mode for the block in the block parameters dialog box.</p>
<p>The output during a write operation depends on the write mode. When the WE is 0, the output port has the value at the location specified by the address line. During a write operation (WE asserted), the data presented on the input data port is stored in memory at the location selected by the port's address input. During a write cycle, you can configure the behavior of data out port B to one of the following choices:</p>
<ul>
<li>Read after write</li>
<li>Read before write</li>
<li>No read on write</li>
</ul>
<p>The write modes can be described with the help of the figure below. In the figure, the memory has been set to an initial value of 5 and the address bit is specified as 4. When using No read on write mode, the output is unaffected by the address line and the output is the same as the last output when the WE was 0. For the other two modes, the output is obtained from the location specified by the address line, and hence is the value of the location being written to. This means that the output can be the old value which corresponds to Read after write.</p>
<p><img src="./Images/xhk1538085518671.png" /></p>
<p>Collision Behavior: The result of simultaneous access to both ports is described below.</p>
<p>Read-Read Collisions: If both ports read simultaneously from the same memory cell, the read operation is successful.</p>
<p>Write-Read Collisions: This collision occurs when one port writes and the other reads from the same memory cell. While the memory contents are not corrupted, the validity of the output data on the read port depends on the Write Mode of the write port.</p>
<ul>
<li>If the write port is in Read before write mode, the other port can reliably read the old memory contents.</li>
<li>If the write port is in Read after write or No read on write, data on the output of the read port is invalid (nan).</li>
</ul>
<p>You can set the Write Mode of port B using the Advanced tab of the block parameters dialog box.</p>
</section>
</section>
</section>
<section id="parameters" class="level2">
<h2>Parameters</h2>
<section id="basic-tab" class="level3">
<h3>Basic tab</h3>
<p>Parameters specific to the Basic tab are as follows.</p>
<section id="depth" class="level4">
<h4>Depth</h4>
<p>Specifies the number of words in the memory for Port A, which must be a positive integer.</p>
</section>
<section id="initial-value-vector" class="level4">
<h4>Initial value vector</h4>
<p>For distributed memory or block RAM, specifies the initial memory contents. The size and precision of the elements of the initial value vector are based on the data format specified for Port A. When the vector is longer than the RAM, the vector's trailing elements are discarded. When the RAM is longer than the vector, the RAM's trailing words are set to zero. The initial value vector is saturated and rounded according to the precision specified on the data port A of RAM.</p>
<p><strong>Note</strong>: UltraRAM memory is initialized to all 0's during power up or device reset. If implemented in UltraRAM, the Simple Dual Port RAM block cannot be initialized to user defined values.</p>
</section>
<section id="memory-type" class="level4">
<h4>Memory Type</h4>
<p>Option to select whether the simple dual-port RAM will be implemented in Distributed memory, Block RAM, or UltraRAM.</p>
<p>Depending on your selection for Memory Type, the simple dual-port RAM will be inferred or implemented in this way when the design is compiled:</p>
<ul>
<li><p>If the block will be implemented in Distributed memory, the Distributed Memory Generator v8.0 LogiCORE IP will be inferred or implemented when the design is compiled. This LogiCORE IP is described in the Distributed Memory Generator LogiCORE IP Product Guide (<a href="https://docs.xilinx.com/access/sources/ud/document?isLatest=true&amp;url=pg063-dist-mem-gen&amp;ft:locale=en-US">PG063</a>).</p></li>
<li><p>If the block will be implemented in block RAM or UltraRAM, the XPM_MEMORY_TDPRAM (True Dual Port RAM) macro will be inferred or implemented when the design is compiled. For information on the XPM_MEMORY_TDPRAM Xilinx Parameterized Macro (XPM), refer to UltraScale Architecture Libraries Guide (<a href="https://docs.xilinx.com/access/sources/dita/map?Doc_Version=2022.2%20English&amp;url=ug974-vivado-ultrascale-libraries">UG974</a>).</p></li>
</ul>
</section>
<section id="initial-value-for-port-b-output-register" class="level4">
<h4>Initial value for port B output register</h4>
<p>Specifies the initial value for port B output register. The initial value is saturated and rounded according to the precision specified on port B of RAM.</p>
</section>
<section id="provide-synchronous-reset-port-for-port-b-output-register" class="level4">
<h4>Provide synchronous reset port for port B output register</h4>
<p>When selected, allows access to the reset port available on the port B output register of the Block RAM or UltraRAM. The reset port is available only when the latency of the Block RAM or UltraRAM is greater than or equal to 1.</p>
</section>
<section id="provide-enable-port-for-port-a" class="level4">
<h4>Provide enable port for port A</h4>
<p>When selected, allows access to the enable port for port A. The enable port is available only when the latency of the block is greater than or equal to 1.</p>
</section>
<section id="provide-enable-port-for-port-b" class="level4">
<h4>Provide enable port for port B</h4>
<p>When selected, allows access to the enable port for port B. The enable port is available only when the latency of the block is greater than or equal to 1.</p>
</section>
</section>
<section id="advanced-tab" class="level3">
<h3>Advanced tab</h3>
<p>Parameters specific to the Advanced tab are as follows.</p>
<section id="write-mode-1" class="level4">
<h4>Write Mode</h4>
<p>When the Simple Dual Port RAM block is implemented in block RAM, specifies memory behavior for port B when WE is asserted. Supported modes are: Read after write, Read before write, and No read on write. Read after write indicates the output value reflects the state of the memory after the write operation. Read before write indicates the output value reflects the state of the memory before the write operation. No read on write indicates that the output value remains unchanged irrespective of change of address or state of the memory. There are device specific restrictions on the applicability of these modes. Also refer to the Write Mode topic above for more information.</p>
<p>Other parameters used by this block are explained in the topic <a href="matlab:helpview(vmcHelp(&#39;name&#39;,&#39;common-options&#39;,&#39;category&#39;,&#39;GEN&#39;))">Common Options in Block Parameter Dialog Boxes</a>.</p>
</section>
</section>
</section>
<section id="examples" class="level2">
<h2>Examples</h2>
<p><em><strong>Click on the images below to open each model.</strong></em></p>
<p><a href="https://github.com/Xilinx/Vitis_Model_Composer/tree/2024.2/Examples/Block_Help/HDL/Simple_DualPortRAM_Ex1"><img src="./Images/Simple_DualPortRAM_Ex1.png" /></a></p>
<p><a href="https://github.com/Xilinx/Vitis_Model_Composer/tree/2024.2/Examples/Block_Help/HDL/Simple_DualPortRAM_Ex2"><img src="./Images/Simple_DualPortRAM_Ex2.png" /></a></p>
</section>
<section id="logicore-and-xpm-documentation" class="level2">
<h2>LogiCOREâ„¢ and XPM Documentation</h2>
<p>Distributed Memory Generator LogiCORE IP Product Guide (<a href="https://docs.xilinx.com/access/sources/ud/document?isLatest=true&amp;url=pg063-dist-mem-gen&amp;ft:locale=en-US">PG063</a>) (Distributed Memory)</p>
<p>UltraScale Architecture Memory Resources User Guide (<a href="https://www.xilinx.com/cgi-bin/docs/ndoc?t=user_guides;d=ug573-ultrascale-memory-resources.pdf">UG573</a>) - XPM_MEMORY_SDPRAM Macro (UltraRAM)</p>
<hr />
<p>Copyright (C) 2024 Advanced Micro Devices, Inc. All rights reserved.</p>
<p>SPDX-License-Identifier: MIT</p>
</section>
</section>
</body>
</html>
